#------generate one data set with epsilon ~ N(0, 0.25)------
seed <- 1152 #seed
n <- 100     #nb of observations
a <- 5       #intercept
b <- 2.7     #slope
set.seed(seed)
epsilon <- rnorm(n, mean=0, sd=sqrt(0.25))
x <- sample(x=c(0, 1), size=n, replace=TRUE)
y <- a + b * x + epsilon
#-----------------------------------------------------------
#------using lm------
mod <- lm(y ~ x)
summary(mod)
x
num <- n * anova(mod)[[3]][2]
num
denom <- n * sum(x^2) - sum(x)^2
confint(mod)
fitted(mod)
as.numeric(fitted(mod))
as.numeric(fitted(mod))-y
residuals(mod)
AIC(mod)
?update
?update
?resid
library(rvest)
library(stringr)
library(magrittr)
library(shiny)
library(shinydashboard)
library(shinyWidgets)
?dashboardSidebar
?box
?fluidRow
server = function(input, output) {
}
page1 <- fluidRow(
box(
title = div(style = 'color:#FFFFFF;font-size:80%;
font-weight: bolder', 'Image Preview'),
width = 12, status = 'primary', solidHeader = T, collapsible = T
)
)
library(rvest)
library(stringr)
library(magrittr)
library(shiny)
library(shinydashboard)
library(shinyWidgets)
##1.标题
shiny.title <- dashboardHeader(title = '送审查询')
##1.标题结束
##2.边栏
shiny.sider <- dashboardSidebar(disable = T)
page1 <- fluidRow(
box(
title = div(style = 'color:#FFFFFF;font-size:80%;
font-weight: bolder', 'Image Preview'),
width = 12, status = 'primary', solidHeader = T, collapsible = T
)
)
shiny.body <- dashboardBody(
#页面布局起始顶级函数
tabItems(
#第一个页面模块的代码
tabItem(tabName = 'input_pre', page1)
)
)
ui <- dashboardPage(
shiny.title,
shiny.sider,
shiny.body
)
server = function(input, output) {
}
shinyApp(ui,server())
shinyApp(ui,server
)
page1 <- fluidRow(
box(
title = div(style = 'color:#FFFFFF;font-size:80%;
font-weight: bolder', 'Image Preview'),
width = 12, status = 'primary', solidHeader = T, collapsible = T,
textInput('usrid', '学号', '')
)
)
library(rvest)
library(stringr)
library(magrittr)
library(shiny)
library(shinydashboard)
library(shinyWidgets)
##1.标题
shiny.title <- dashboardHeader(title = '送审查询')
##1.标题结束
##2.边栏
shiny.sider <- dashboardSidebar(disable = T)
page1 <- fluidRow(
box(
title = div(style = 'color:#FFFFFF;font-size:80%;
font-weight: bolder', 'Image Preview'),
width = 12, status = 'primary', solidHeader = T, collapsible = T,
textInput('usrid', '学号', '')
)
)
shiny.body <- dashboardBody(
#页面布局起始顶级函数
tabItems(
#第一个页面模块的代码
tabItem(tabName = 'input_pre', page1)
)
)
ui <- dashboardPage(
shiny.title,
shiny.sider,
shiny.body
)
server = function(input, output) {
}
runApp('C:/Users/snow/Desktop/songshen.R')
runApp('C:/Users/snow/Desktop/songshen.R')
runApp('C:/Users/snow/Desktop/songshen.R')
runApp('C:/Users/snow/Desktop/songshen.R')
runApp('C:/Users/snow/Desktop/songshen.R')
runApp('C:/Users/snow/Desktop/songshen.R')
runApp('C:/Users/snow/Desktop/songshen.R')
runApp('C:/Users/snow/Desktop/songshen.R')
runApp('C:/Users/snow/Desktop/songshen.R')
runApp('C:/Users/snow/Desktop/songshen.R')
runApp('C:/Users/snow/Desktop/songshen.R')
runApp('C:/Users/snow/Desktop/songshen.R')
runApp('C:/Users/snow/Desktop/songshen.R')
runApp('C:/Users/snow/Desktop/songshen.R')
runApp('C:/Users/snow/Desktop/songshen.R')
runApp('C:/Users/snow/Desktop/songshen.R')
runApp('C:/Users/snow/Desktop/songshen.R')
runApp('C:/Users/snow/Desktop/songshen.R')
runApp('C:/Users/snow/Desktop/songshen.R')
runApp('C:/Users/snow/Desktop/songshen.R')
n1 = rnorm(1)
n1
z=0
for (i in 1:200) {
n1 = abs(rnorm(1))
if(n1 >= 2) z=z+1
}
z
z=0
for (i in 1:200) {
n1 = abs(rnorm(1))
if(n1 >= 2) z=z+1
}
z
z=0
for (i in 1:200) {
n1 = abs(rnorm(1))
if(n1 >= 2) z=z+1
}
z
z=0
for (i in 1:200) {
n1 = abs(rnorm(1))
if(n1 >= 2) z=z+1
}
z
runApp('C:/Users/snow/Desktop/songshen.R')
runApp('C:/Users/snow/Desktop/songshen.R')
msg <- paste0('已有通过',c1-c2,'个，未通过', c2,'个 (友情提示：不要干坏事，悄悄地干也被会我发现的哦，不属于自己的物品不要乱动)')
c1=1
c2=0
msg <- paste0('已有通过',c1-c2,'个，未通过', c2,'个 (友情提示：不要干坏事，悄悄地干也被会我发现的哦，不属于自己的物品不要乱动)')
msg
69.5/53.1*400
?chisq.test
x <- c(210,312,170,85,223)
y = rep(200,5)
chisq.test(x,y)
x = matrix(c(60,3,32,11),nrow=2)
chisq.test(x)
x=c(60,3)
y=c(32,11)
chisq.test(x,y)
x = matrix(c(60,3,32,11),nrow=2)
fisher.test(x)
?nearPith
library(MtreeRing)
?nearPith
setwd("~/GitHub/MtreeRing")
require(knitr);require(markdown);knit("README.Rmd")
require(knitr);require(markdown);knit("README.Rmd")
knit("README.Rmd")
getwd()
library(usethis)
?use_code_of_conduct
use_code_of_conduct(path = NULL)
knit("README.Rmd")
?use_gpl3_license
install.packages('gistr')
vignette(package='gistr')
?vignette
vignette(gistr_vignette)
vignette('gistr_vignette')
vignette(package='MtreeRing')
vignette('introduction')
vignette('introduction',package='MtreeRing')
vignette('gistr_vignette')
library(MtreeRing)
## Read and plot a tree ring image
img.name <- system.file("001.png", package = "MtreeRing")
t1 <- imgInput(img = img.name, dpi = 1200)
## Split a long core sample into 2 pieces to
## get better display performance and use the
## watershed algorithm to detect ring borders:
t2 <- autoDetect(ring.data = t1, auto.path = TRUE, seg = 2, method = 'watershed')
img.name <- system.file("incline.png", package = "MtreeRing")
t1 <- imgInput(img = img.name, dpi = 1200)
t2 <- autoDetect(ring.data = t1, incline = TRUE, method = 'watershed')
rw.df <- calcRingWidth(ring.data = t2, seriesID = "940220")
install.packages("~/GitHub/MtreeRing_1.2.tar.gz", repos = NULL, type = "source")
vignette(package='MtreeRing')
vignette('MtreeRing_vignette')
img.name <- system.file("001.png", package = "MtreeRing")
t1 <- imgInput(img = img.name, dpi = 1200)
t2 <- autoDetect(ring.data = t1, auto.path = TRUE, seg = 2, method = 'watershed')
t2 <- autoDetect(ring.data = t1, incline = TRUE, method = 'watershed')
t2 <- autoDetect(ring.data = t1, incline = TRUE, method = 'watershed',seg=3)
img.name <- system.file("incline.png", package = "MtreeRing")
t1 <- imgInput(img = img.name, dpi = 1200)
t2 <- autoDetect(ring.data = t1, incline = TRUE, method = 'watershed')
img.name <- system.file("incline.png", package = "MtreeRing")
t1 <- imgInput(img = img.name, dpi = 1200)
t2 <- autoDetect(ring.data = t1, incline = TRUE, method = 'watershed',seg = 2)
img.name <- system.file("incline.png", package = "MtreeRing")
t1 <- imgInput(img = img.name, dpi = 1200)
t2 <- autoDetect(ring.data = t1, incline = TRUE, method = 'watershed',seg = 2, border.color = 'green')
img.name <- system.file("incline.png", package = "MtreeRing")
t1 <- imgInput(img = img.name, dpi = 1200)
t2 <- autoDetect(ring.data = t1, incline = TRUE, method = 'watershed',seg = 2)
img.name <- system.file("001.png", package = "MtreeRing")
t1 <- imgInput(img = img.name, dpi = 1200)
t2 <- autoDetect(ring.data = t1, auto.path = TRUE, seg = 2, method = 'watershed')
t2 <- autoDetect(ring.data = t1, auto.path = TRUE, seg = 2, method = 'watershed',border.color = 'green')
img.name <- system.file("incline.png", package = "MtreeRing")
t1 <- imgInput(img = img.name, dpi = 1200)
t2 <- autoDetect(ring.data = t1, incline = TRUE, method = 'watershed')
img.name <- system.file("incline.png", package = "MtreeRing")
t1 <- imgInput(img = img.name, dpi = 1200)
t2 <- autoDetect(ring.data = t1, incline = TRUE, method = 'watershed',seg = 2)
library(MtreeRing)
img.name <- system.file("incline.png", package = "MtreeRing")
t1 <- imgInput(img = img.name, dpi = 1200)
t2 <- autoDetect(ring.data = t1, incline = TRUE, method = 'watershed',seg = 2)
?calcRingWidth
